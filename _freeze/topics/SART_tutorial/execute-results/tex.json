{
  "hash": "8e6690313df63acd49457cbcd9dc3fe8",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"SAR Tomography of Tropical Forests\"\nauthor: \"Xiao Liu\"\ndate: today\njupyter: anaconda_base\nformat:\n  html:\n    toc: true\n    toc-depth: 3\n    code-fold: false\n    theme: cosmo\n    embed-resources: true\n    number-sections: true\n  pdf:\n    toc: true\n    number-sections: true\nexecute:\n  warning: false\n  message: false\n  freeze: auto\n  fig-width: 8        # Default width in inches\n  fig-height: 6       # Default height in inches\n  fig-dpi: 150        # Resolution (default is 96)\neditor: visual\n---\n\n## Overview\n\nThis tutorial demonstrates SAR tomography (TomoSAR) analysis of tropical forests using P-band data from the AfriSAR 2016 campaign. We'll process multi-baseline SAR data to extract 3D forest structure information and compare results with LiDAR measurements. The analysis covers data preprocessing, covariance matrix computation, tomographic inversion, and validation against airborne LiDAR forest height and biomass data.\n\n::: callout-note\n## Tutorial Background\n\nThis script is developed based on the [TomoSAR tutorial from EO-College](https://github.com/EO-College/tomography_tutorial).\n\n**Data**: [F-SAR P-band TomoSAR data from AfriSAR 2016 campaign](https://drive.google.com/file/d/1eMuHnjJNZy8F_q6qC7Mzazw8e8WmV_By/view?usp=drive_link) **Study site**: Lopé National Park, Gabon **Contact**: xiao.liu\\@mailbox.tu-dresden.de\n:::\n\n## Prerequisites\n\nBefore starting, you'll need to install the required Python packages and set up your working environment.\n\n::: {#setup-packages .cell execution_count=1}\n``` {.python .cell-code}\n# Install required python packages (uncomment if needed)\n# !pip install -r requirements.txt\n\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\nfrom sys import exit\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n```\n:::\n\n\n## Part 1: Data Preparation\n\n### Setting Up the Working Directory\n\nDefine the project paths for input data, code, and output storage:\n\n::: {#setup-paths-display .cell execution_count=2}\n``` {.python .cell-code}\n# Set the project path (UPDATE THIS to your actual path)\nproject_path = 'E:/TomoSAR/'\n\ninpath = os.path.join(project_path, 'data')\nworkspace = os.path.join(project_path, 'code')\nos.chdir(workspace)\n```\n:::\n\n\n\n\n### Importing TomoSAR Functions\n\nLoad the specialized functions for tomographic processing and visualization:\n\n::: {#import-functions .cell execution_count=4}\n``` {.python .cell-code}\nfrom tomosar_toolbox import tomobox, normalize, topo_residual_correction, \\\n                         covmat_downsampling\nfrom tomosar_plotting import cov_mat_plot, tomo_plot, \\\n                             grouped_tomosar_profiles, tomosar_phase_centre, \\\n                             tomosar_layerd_reflectivity, quick_look, insar_quick_look\n```\n:::\n\n\n::: callout-important\n## Required Functions\n\nThese custom functions handle the core TomoSAR processing pipeline. Ensure the `tomosar_toolbox.py` and `tomosar_plotting.py` modules are in your workspace directory.\n:::\n\n## Part 2: Parameter Configuration\n\n### Defining Processing Parameters\n\nConfigure the key parameters for TomoSAR processing:\n\n::: {#set-parameters .cell execution_count=5}\n``` {.python .cell-code}\n# Pixel spacing\nps_rg = 1.19  # Pixel spacing in range (meters)\nps_az = 0.9   # Pixel spacing in azimuth (meters)\n\n# Define the boxcar smoothing dimension (in meters)\nmulti_look = 25  # Options: 25, 50\n\n# Define the max height for the inversion\nheight = 65\nz_vector = np.arange(-height, height + 1, 1)\n\n# Select polarization\npol = 'hh'  # Options: 'hh', 'hv', 'vv'\n\n# Select TomoSAR algorithm\ntomo_method = 'capon'  # Options: 'capon', 'beamforming'\n\n# Flag for terrain normalization\nterrain_cor_flag = 0  # 0: without terrain normalization, 1: with terrain normalization\n\nif terrain_cor_flag == 0: \n    outpath = os.path.join(project_path, 'out')  # Save results without terrain normalization\nelse:\n    outpath = os.path.join(project_path, 'out/terrain_normalised')  # Save results with terrain normalization\n```\n:::\n\n\n::: callout-tip\n## Parameter Selection\n\n-   **Multi-look size**: Larger values (50m) provide more stable estimates but lower spatial resolution\n-   **Polarization**: HH is most sensitive to forest structure; HV to volume scattering\n-   **Capon beamformer**: Provides better vertical resolution than conventional beamforming\n-   **Terrain correction**: Essential for accurate height estimation in sloped terrain\n:::\n\n## Part 3: Data Loading and Visualization\n\n### Loading SAR Data\n\nRead the pre-processed SAR data stack:\n\n::: {#load-sar-data .cell execution_count=6}\n``` {.python .cell-code}\noutname = os.path.join(inpath, '{}_sample_data.npz'.format(pol))\ndata = np.load(outname)\n\nslc_stack = data['slc_stack']      # Single Look Complex (SLC) image\nkz_stack = data['kz_stack']        # Vertical wavenumber\nphase_stack = data['phase_stack']  # Topographical phase\n\n# Optional: use subset for testing\n# slc_stack = slc_stack[:,:,:5]\n# kz_stack = kz_stack[:,:,:5]\n# phase_stack = phase_stack[:,:,:5]\n\ndel data\n\nn_row, n_col, n_track = slc_stack.shape\n\nprint(f\"Data dimensions: {slc_stack.shape}\")\nprint(f\"Number of tracks: {n_track}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nData dimensions: (1100, 1000, 10)\nNumber of tracks: 10\n```\n:::\n:::\n\n\n::: callout-note\n## Data Structure\n\nThe data contains:\n\n-   **slc_stack**: Complex SAR image stack (rows × columns × tracks)\n-   **kz_stack**: Vertical wavenumber for each baseline\n-   **phase_stack**: Topographic phase for each acquisition\n:::\n\n### Quick Look at SAR Data\n\nVisualize the SAR intensity, phase, vertical wavenumber, and topographic phase:\n\n::: {.cell fig-height='8' fig-width='12' execution_count=7}\n``` {.python .cell-code}\nslc_id = 3\nimg_path = os.path.join(outpath, 'Track_{}_quick_look.png'.format(slc_id))         \nquick_look(slc_id, slc_stack, kz_stack, phase_stack, img_path,\n          figsize=(10, 8), dpi=150, fontsize=12)\n```\n\n::: {.cell-output .cell-output-display}\n![Quick look at SAR data: intensity, phase, kz, and topographic phase](SART_tutorial_files/figure-pdf/quicklook-sar-output-1.pdf){#quicklook-sar fig-pos='H'}\n:::\n:::\n\n\n## Part 4: Phase Calibration\n\n### Removing Flat-Earth and Topography Phase\n\nCalibrate the SAR data by removing the flat-earth and topographic phase contributions:\n\n::: {#phase-calibration .cell execution_count=8}\n``` {.python .cell-code}\nprint('Remove flat-earth and topography phase')\noutname = os.path.join(outpath, '{}_normalized_stack.npy'.format(pol))\n\nnormalized_stack = slc_stack.copy()\n# Start from second SLC (kz and dem_phase of master SLC are 0)\nfor n in tqdm(range(1, n_track)):\n    dem_phase = phase_stack[:,:,n].squeeze()\n    slc_uncal = slc_stack[:,:,n].squeeze()\n    normalized_stack[:,:,n] = slc_uncal * np.exp(1j * dem_phase)  # Phase calibration\ndel dem_phase, slc_uncal\n\nnp.save(outname, normalized_stack)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRemove flat-earth and topography phase\n```\n:::\n:::\n\n\n::: callout-important\n## Why Phase Calibration Matters\n\nThe flat-earth and topographic phases dominate the interferometric phase and must be removed to isolate the vertical structure information. This step is crucial for accurate TomoSAR reconstruction.\n:::\n\n### Removing Residual Topography Phase\n\nFor terrain-corrected processing, remove any remaining topographic phase:\n\n::: {#terrain-correction .cell fig-height='6' fig-width='8' execution_count=9}\n``` {.python .cell-code}\nif terrain_cor_flag == 1:\n    hh_tomo_path = os.path.join(project_path + 'out/',\n                                'hh_tomo_ml{}_h{}_capon.npy'.format(multi_look, height))\n    \n    if os.path.isfile(hh_tomo_path) == False:\n        print('Please first calculate the HH tomography without terrain correction.')\n        terrain_cor_flag = 0\n        exit(0)\n    else:\n        print('Remove residual topography phase')\n        terrain_path = os.path.join(project_path + 'out/',\n                                    'tomo_ml{}_h{}'.format(multi_look, height) + '_hh_capon_terrain.npy')\n        \n        normalized_stack, terrain = topo_residual_correction(normalized_stack, kz_stack, z_vector, \n                                                             hh_tomo_path, terrain_path)\n        \n        # Plot terrain residual\n        plt.figure(dpi=300)\n        plt.imshow(terrain, cmap='jet', vmax=30, vmin=-30)\n        plt.colorbar()\n        plt.title('Topography residual (m)')\n        plt.show()\n```\n:::\n\n\n### Visualizing Phase Calibration Results\n\nCompare the interferometric phase before and after calibration:\n\n::: {.cell fig-height='6' fig-width='12' execution_count=10}\n``` {.python .cell-code}\nslc_1_id, slc_2_id = 1, 3\ninsar_quick_look(slc_1_id, slc_2_id, slc_stack, normalized_stack,\n                figsize=(12, 5), dpi=150)\n```\n\n::: {.cell-output .cell-output-display}\n![InSAR phase before and after removing flat-earth and topography phase](SART_tutorial_files/figure-pdf/compare-insar-phase-output-1.pdf){#compare-insar-phase fig-pos='H'}\n:::\n:::\n\n\n## Part 5: Covariance Matrix Computation\n\n### Computing Covariance Matrix with Multi-looking\n\nCalculate the covariance matrix with spatial averaging to improve signal-to-noise ratio:\n\n::: {#compute-covariance .cell execution_count=11}\n``` {.python .cell-code}\nprint('Calculate covariance matrix')\ncovariance_matrix, r_out_smpl, x_out_smpl = covmat_downsampling(normalized_stack, multi_look, ps_rg, ps_az)\noutname = os.path.join(outpath, '{}_cov_matrix_ml{}.npy'.format(pol, multi_look))\nnp.save(outname, covariance_matrix)\n\n# Update kz using downsampling index along azimuth and range\nkz_stack_down = kz_stack[r_out_smpl,:,:][:,x_out_smpl,:]\n\nprint(f\"Covariance matrix shape: {covariance_matrix.shape}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCalculate covariance matrix\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nCovariance matrix shape: (180, 139, 10, 10)\n```\n:::\n:::\n\n\n::: callout-tip\n## Multi-looking Trade-off\n\nMulti-looking reduces speckle noise but decreases spatial resolution. The 25m window size balances these considerations for forest structure analysis.\n:::\n\n### Visualizing Covariance Matrix\n\nDisplay the covariance matrix structure:\n\n::: {.cell fig-height='8' fig-width='10' execution_count=12}\n``` {.python .cell-code}\nimg_path = os.path.join(outpath, '{}_covariance_matrix_quick_look.png'.format(pol))\ncov_mat_plot(covariance_matrix, img_path,\n            figsize=(10, 10), dpi=150, fontsize=18)\n```\n\n::: {.cell-output .cell-output-display}\n![Covariance matrix visualization](SART_tutorial_files/figure-pdf/plot-covariance-output-1.pdf){#plot-covariance fig-pos='H'}\n:::\n:::\n\n\n## Part 6: Tomographic Inversion\n\n### Computing TomoSAR Reflectivity Profiles\n\nPerform the tomographic inversion to estimate vertical backscatter profiles:\n\n::: {#tomosar-inversion .cell execution_count=13}\n``` {.python .cell-code}\ntomo = tomobox(covariance_matrix, kz_stack_down, z_vector, outname, tomo_method)\n\noutname = os.path.join(outpath, '{}_tomo_ml{}_h{}_{}.npy'.format(pol, multi_look, height, tomo_method))\nnp.save(outname, tomo)\n\nprint(f\"TomoSAR result shape: {tomo.shape}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTomoSAR result shape: (180, 139, 131)\n```\n:::\n:::\n\n\n::: callout-note\n## TomoSAR Methods\n\n-   **Capon (MVDR)**: Minimum Variance Distortionless Response beamformer, provides better resolution\n-   **Beamforming**: Conventional delay-and-sum beamformer, more robust but lower resolution\n:::\n\n### Normalizing Reflectivity Profiles\n\nNormalize the tomographic reflectivity to \\[0, 1\\] for each pixel:\n\n::: {#normalize-tomo .cell execution_count=14}\n``` {.python .cell-code}\ntomo_norm = np.apply_along_axis(normalize, 2, tomo)\n```\n:::\n\n\n### Visualizing Tomographic Results\n\nPlot example vertical reflectivity profiles:\n\n::: {.cell fig-height='8' fig-width='10' execution_count=15}\n``` {.python .cell-code}\nrg_ratio, az_ratio = 0.5, 0.6\n\nrg, az = int(rg_ratio * tomo_norm.shape[1]), int(az_ratio * tomo_norm.shape[0])\nimg_path = os.path.join(outpath, '{}_tomosar_example_az_{}_rg_{}_{}.png'.format(pol, az, rg, tomo_method))\ntomo_plot(rg, az, slc_stack, tomo_norm, height, pol, img_path,\n         figsize=(10, 8), dpi=150, fontsize=12)\n```\n\n::: {.cell-output .cell-output-display}\n![Example TomoSAR vertical reflectivity profile](SART_tutorial_files/figure-pdf/plot-tomo-example-output-1.pdf){#plot-tomo-example fig-pos='H'}\n:::\n:::\n\n\n::: callout-important\n## Interpreting Reflectivity Profiles\n\nThe vertical reflectivity profile shows:\n\n-   **Ground peak**: Strong backscatter from the ground surface\n-   **Canopy volume**: Distributed scattering from vegetation layers\n-   **Canopy top**: Upper extent of forest structure\n:::\n\n## Part 7: Validation with LiDAR Data\n\n### Loading LiDAR Reference Data\n\nLoad airborne LiDAR forest height and above-ground biomass data:\n\n::: {#load-lidar .cell execution_count=16}\n``` {.python .cell-code}\nif terrain_cor_flag == 1:\n    lvis_rh_path = os.path.join(inpath, 'lidar_rh100_25m.npy')\n    lvis_agb_path = os.path.join(inpath, 'lidar_agb_50m.npy')\n    \n    lvis_rh = np.load(lvis_rh_path)\n    lvis_agb = np.load(lvis_agb_path)\n    \n    from skimage.transform import resize\n    lvis_rh = resize(lvis_rh, (tomo_norm.shape[0], tomo_norm.shape[1]))\n    lvis_agb = resize(lvis_agb, (tomo_norm.shape[0], tomo_norm.shape[1]))\n    \n    print(f\"LiDAR height range: {lvis_rh.min():.2f} - {lvis_rh.max():.2f} m\")\n    print(f\"LiDAR AGB range: {lvis_agb.min():.2f} - {lvis_agb.max():.2f} Mg/ha\")\n```\n:::\n\n\n::: callout-note\n## LiDAR Data Resolution\n\n-   **Forest height (RH100)**: 25 m resolution\n-   **Above-ground biomass (AGB)**: 50 m resolution\n\nBoth are resampled to match the TomoSAR grid.\n:::\n\n### Comparing TomoSAR with LiDAR Height\n\nOverlay LiDAR forest height on TomoSAR profiles:\n\n::: {#compare-lidar-height .cell fig-height='8' fig-width='10' execution_count=17}\n``` {.python .cell-code}\nif terrain_cor_flag == 1:\n    rg_ratio, az_ratio = np.random.rand(), np.random.rand()\n    rg, az = int(rg_ratio * tomo_norm.shape[1]), int(az_ratio * tomo_norm.shape[0])\n    \n    img_path = os.path.join(outpath, '{}_tomosar_example_az_{}_rg_{}_lidar.png'.format(pol, az, rg))\n    tomo_plot(rg, az, slc_stack, tomo_norm, height, pol, img_path, lvis_rh,\n             figsize=(10, 8), dpi=150, fontsize=12)\n```\n:::\n\n\n### Aggregating Profiles by Forest Height and Biomass\n\nAnalyze TomoSAR reflectivity patterns across different forest height and biomass classes:\n\n::: {#aggregate-profiles .cell fig-height='8' fig-width='12' execution_count=18}\n``` {.python .cell-code}\nif terrain_cor_flag == 1:\n    img_path = os.path.join(outpath, '{}_tomosar_aggregated_profiles.png'.format(pol))\n    grouped_tomosar_profiles(tomo, lvis_rh, lvis_agb, z_vector, img_path,\n                             figsize=(11, 6), dpi=150, fontsize=12)\n```\n:::\n\n\n### TomoSAR Phase Center vs. LiDAR Height\n\nCompare the TomoSAR phase center with LiDAR forest height:\n\n::: {#phase-center-comparison .cell fig-height='8' fig-width='10' execution_count=19}\n``` {.python .cell-code}\nif terrain_cor_flag == 1:\n    img_path = os.path.join(outpath, 'lidar_height_{}_tomosar_phase_centre.png'.format(pol))\n    tomosar_phase_centre(tomo, lvis_rh, z_vector, img_path,\n                         figsize=(12, 4), dpi=150)\n```\n:::\n\n\n::: callout-tip\n## Phase Center Height\n\nThe phase center represents the weighted center of the vertical backscatter distribution. For forests, it typically falls between the ground and canopy top, depending on penetration depth and canopy structure.\n:::\n\n### Layer-wise Reflectivity vs. Biomass\n\nExamine TomoSAR reflectivity at different height layers in relation to biomass:\n\n::: {#layered-reflectivity .cell fig-height='10' fig-width='12' execution_count=20}\n``` {.python .cell-code}\nif terrain_cor_flag == 1:\n    min_agb = 50  # Minimum AGB threshold (Mg/ha)\n    img_path = os.path.join(outpath, 'lidar_agb_{}_tomosar_reflectivity_at'.format(pol))\n    tomosar_layerd_reflectivity(tomo, lvis_agb, min_agb, height, img_path,\n                                figsize=(12, 4), dpi=150)\n```\n:::\n\n\n## Summary and Exercises\n\n::: panel-tabset\n## Key Takeaways\n\n**Data Preprocessing** - Multi-baseline SAR data requires careful phase calibration - Terrain correction is essential for accurate height estimation - Multi-looking balances noise reduction and spatial resolution\n\n**Tomographic Inversion** - Capon beamformer provides better vertical resolution than conventional methods - Vertical profiles reveal ground and canopy structure - Phase center height correlates with forest structure\n\n**Validation Results** - TomoSAR profiles show strong agreement with LiDAR measurements - Penetration depth varies with polarization and forest density - Biomass estimation benefits from multi-layer information\n\n## Best Practices\n\n-   Always perform terrain correction for sloped terrain\n-   Use HH polarization for maximum ground penetration\n-   Validate results with independent reference data (LiDAR, field measurements)\n-   Consider multiple polarizations for comprehensive analysis\n-   Document all processing parameters for reproducibility\n\n## Exercises\n\n**Compare results using different:**\n\n1.  **Polarizations**: HH, HV, VV\n    -   How does penetration depth vary?\n    -   Which polarization best correlates with biomass?\n2.  **Tomography methods**: Capon vs. Beamforming\n    -   Compare vertical resolution\n    -   Assess robustness to noise\n3.  **Multi-look sizes**: 25m vs. 50m\n    -   Trade-off between resolution and stability\n    -   Impact on height estimation accuracy\n4.  **Dataset size**: Full dataset vs. subset\n    -   Effect of number of baselines\n    -   Minimum tracks required for reliable inversion\n:::\n\n## Conclusion\n\nThis tutorial demonstrates a complete workflow for SAR tomography of tropical forests, from data preprocessing through validation with LiDAR. The ability to extract 3D forest structure from SAR data provides valuable information for biomass estimation, forest monitoring, and carbon accounting, especially in tropical regions where optical remote sensing is limited by cloud cover.\n\nThe integration of multiple polarizations, processing methods, and independent validation data creates a robust framework for understanding forest vertical structure. These techniques are applicable to various forest types and SAR systems, making them valuable tools for large-scale forest monitoring.\n\n::: callout-warning\n## Important Considerations\n\nWhen applying these methods to your own data:\n\n-   **Baseline configuration**: Ensure adequate vertical wavenumber sampling\n-   **Data quality**: Check for phase unwrapping errors and temporal decorrelation\n-   **Terrain effects**: Always apply terrain correction in mountainous areas\n-   **Validation data**: Use concurrent LiDAR or field measurements when possible\n-   **Processing parameters**: Adjust multi-look size based on forest heterogeneity\n:::\n\n------------------------------------------------------------------------\n\n*This tutorial provides both theoretical understanding and practical implementation for SAR tomography analysis. The modular structure allows adaptation to different datasets and research questions.*\n\n---\n\n![](logos.png)\n\n",
    "supporting": [
      "SART_tutorial_files\\figure-pdf"
    ],
    "filters": []
  }
}